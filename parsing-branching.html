<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2.1&nbsp;Providing multiple paths</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Megaparsack:<span class="mywbr"> &nbsp;</span> Practical Parser Combinators</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="parsing-basics.html" class="tocviewlink" data-pltdoc="x">Parsing Basics</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="choice.html" class="tocviewselflink" data-pltdoc="x">Parsers with Choice</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="producing-syntax.html" class="tocviewlink" data-pltdoc="x">Producing Syntax</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="reference.html" class="tocviewlink" data-pltdoc="x">API Reference</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="differences-from-parsack.html" class="tocviewlink" data-pltdoc="x">Appendix:<span class="mywbr"> &nbsp;</span> Parsack vs Megaparsack</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>2&nbsp;</td><td><a href="choice.html" class="tocviewlink" data-pltdoc="x">Parsers with Choice</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Providing multiple paths</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="Parsing_sequences.html" class="tocviewlink" data-pltdoc="x">Parsing sequences</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>2.1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Providing multiple paths</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="#%28part._.Parsing_ambiguous_grammars%29" class="tocviewlink" data-pltdoc="x">Parsing ambiguous grammars</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="#%28part._.Backtracking_with_caution%29" class="tocviewlink" data-pltdoc="x">Backtracking with caution</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Parsing_ambiguous_grammars%29" class="tocsubseclink" data-pltdoc="x">Parsing ambiguous grammars</a></td></tr><tr><td><span class="tocsublinknumber">2.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Backtracking_with_caution%29" class="tocsubseclink" data-pltdoc="x">Backtracking with caution</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="choice.html" title="backward to &quot;2 Parsers with Choice&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="choice.html" title="up to &quot;2 Parsers with Choice&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Parsing_sequences.html" title="forward to &quot;2.2 Parsing sequences&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>2.1<tt>&nbsp;</tt><a name="(part._parsing-branching)"></a>Providing multiple paths</h4><p>To create a parser with multiple possibilities, use the <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span> combinator. It accepts any
number of parsers, and it tries them one at a time until one of them matches. For example, let&#8217;s
consider a parser that parses either the string <span class="RktVal">"true"</span> or <span class="RktVal">"false"</span>, then returns the
value as a Racket boolean:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">true/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"true"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28def._%28%28lib._data%2Fapplicative..rkt%29._pure%29%29" class="RktValLink" data-pltdoc="x">pure</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">false/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"false"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28def._%28%28lib._data%2Fapplicative..rkt%29._pure%29%29" class="RktValLink" data-pltdoc="x">pure</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">boolean/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktSym">true/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">false/p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote><p>By using <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span>, we&#8217;ve created a choice point, where the parser will try each path before
giving up. If none of the paths match, the parser will still fail, but if any of the paths match, it
will consider the parse successful and return. To demonstrate that this works, we can use our new
parser on some strings:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">boolean/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"true"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success #t)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">boolean/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"false"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success #f)</span></p></td></tr></table></blockquote><p>The <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span> combinator also automatically cooperates with error handling to provide helpful
error messages when parsing fails:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._parse-result%21%29%29" class="RktValLink" data-pltdoc="x">parse-result!</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">boolean/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"not a boolean"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">string:1:0: parse error</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">unexpected: n</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: false or true</span></p></td></tr></table></blockquote><p>Note that the error includes all the possible values that would have been considered valid at the
point that the parser failed.</p><p>Remember that the <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span> combinator is not magic: it does not attempt to predict which parse
will be valid, and it does not even try to look ahead to see which parse will be the longest. This can
cause problems when two different parses could <span style="font-style: italic">both</span> succeed&#8212;<span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span> will just pick the
first one:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">overlapping/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success "hello")</span></p></td></tr></table></blockquote><p>Just like ordinary boolean <span class="RktSym"><a href="http://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._or%29%29" class="RktStxLink" data-pltdoc="x">or</a></span>, keep in mind that order does matter with <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span>.</p><h5>2.1.1<tt>&nbsp;</tt><a name="(part._.Parsing_ambiguous_grammars)"></a>Parsing ambiguous grammars</h5><p>So, if <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span> does not perform any lookahead, how exactly does it choose between parsers? It
might <span style="font-style: italic">seem</span> like it tries each parser completely, then backtracks when any of them fail, but
this is not entirely true&#8212;consider the parser above, fixed so the longest match is first:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">overlapping/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote><p>You might expect that, if the first match fails, it will try the second one, but in practice, this
doesn&#8217;t actually work:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success "hello, world!")</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._parse-result%21%29%29" class="RktValLink" data-pltdoc="x">parse-result!</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">string:1:4: parse error</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">unexpected: end of input</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: , world!</span></p></td></tr></table></blockquote><p>What gives? Take a close look at the error message: it is expecting the rest of <span class="stt">hello, world!</span>,
but obviously we only gave it <span class="stt">hello</span>. Why isn&#8217;t the parser backtracking? Well, megaparsack
actually does not backtrack by default. Instead, it implements a single-character lookahead: it tries
to parse the first token from each branch, and if it succeeds, it <span style="font-style: italic">commits</span> to that path.</p><p>This means that, since part of the <span class="stt">hello, world</span> parse was successful, the parser has already
committed to that branch and will not try any of the other options. This turns out to provide far
superior error reporting because it reports to the user precisely where the error occurred, not
somewhere much earlier in the parse. However, this obviously causes problems in this case where the
parse is <span style="font-style: italic">ambiguous</span>, or more generally, the choice cannot be determined by a single character
of lookahead.</p><p>To solve this by allowing the parser to backtrack, use the <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> combinator, which converts
a parser into one the backtracks upon failure. We can use this to solve our issue with our parser:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">backtracking-overlapping/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hello"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">backtracking-overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello, world!"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success "hello, world!")</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">backtracking-overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"hello"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success "hello")</span></p></td></tr></table></blockquote><p>All that <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> does is disable the &#8220;committing&#8221; behavior mentioned earlier: instead of
committing to a particular path once any of the parse succeeds, any error that occurs within the
parser provided to <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> is non-fatal, and the parser will backtrack and try the next
alternative.</p><h5>2.1.2<tt>&nbsp;</tt><a name="(part._.Backtracking_with_caution)"></a>Backtracking with caution</h5><p>In this case, since the parse is truly ambiguous based on the first character, <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> is the
correct approach. Note that the error messages are still helpful upon failure:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._parse-result%21%29%29" class="RktValLink" data-pltdoc="x">parse-result!</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">backtracking-overlapping/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"not hello"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">string:1:0: parse error</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">unexpected: n</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: hello or hello, world!</span></p></td></tr></table></blockquote><p>However, be deliberate about where you put <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> because it is very easy to end up with a
parser that provides completely useless error messages because all errors simply backtrack instead of
failing fast and reporting the real problem. For an example of this, consider a parser that parses an
integer or a boolean, depending on a label provided first:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">the-labeled-integer/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"the integer: "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._integer%2Fp%29%29" class="RktValLink" data-pltdoc="x">integer/p</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">the-labeled-boolean/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"the boolean: "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">boolean/p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote><p>It might be tempting to use <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> here because we know that the integer case might fail.
Therefore, you might write the parser like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">try-labeled/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span><span class="hspace">&nbsp;</span><span class="RktSym">the-labeled-integer/p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">the-labeled-boolean/p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote><p>This parser seems innocuous enough, right? It even works successfully:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">try-labeled/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"the integer: 42"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success 42)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">try-labeled/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"the boolean: false"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(success #f)</span></p></td></tr></table></blockquote><p>But there is a lurking problem with this parser, and that&#8217;s its error messages. Consider a mismatch,
when we provide the <span class="stt">the integer:</span> label but do not actually provide an integer:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._parse-result%21%29%29" class="RktValLink" data-pltdoc="x">parse-result!</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">try-labeled/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"the integer: false"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">string:1:3: parse error</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">unexpected: i</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: boolean: </span></p></td></tr></table></blockquote><p>Oops. What happened? Well, the parser tried to parse an integer, but it failed, so it backtracked. It
then tried to parse a boolean, and it parsed the <span class="stt">the</span>, but then it failed, too, so it reported an
error message. To a user, though, that error message is totally useless. The <span style="font-style: italic">actual</span> issue is
that they should have provided an integer, but instead provided a boolean. Unfortunately, the
overzealous backtracking has eliminated that information.</p><p>This is tricky, because we can&#8217;t just drop the <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span>&#8212;since both cases share <span class="stt">the</span>, the
parse is ambiguous without a little bit of lookahead. In order to fix this, what we really want to
do is factor out the common <span class="stt">the</span>, which will allow us to eliminate the <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span> altogether:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">labeled-integer/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"integer: "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._integer%2Fp%29%29" class="RktValLink" data-pltdoc="x">integer/p</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">labeled-boolean/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"boolean: "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">boolean/p</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">labeled/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29" class="RktStxLink" data-pltdoc="x">do</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._string%2Fp%29%29" class="RktValLink" data-pltdoc="x">string/p</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"the "</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._or%2Fp%29%29" class="RktValLink" data-pltdoc="x">or/p</a></span><span class="hspace">&nbsp;</span><span class="RktSym">labeled-integer/p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">labeled-boolean/p</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote><p>Since we&#8217;ve removed all of the uses of <span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._try%2Fp%29%29" class="RktValLink" data-pltdoc="x">try/p</a></span>, now the parser can provide much more precise
error messages when we provide invalid input.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Fmain..rkt%29._parse-result%21%29%29" class="RktValLink" data-pltdoc="x">parse-result!</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="reference.html#%28def._%28%28lib._megaparsack%2Ftext..rkt%29._parse-string%29%29" class="RktValLink" data-pltdoc="x">parse-string</a></span><span class="hspace">&nbsp;</span><span class="RktSym">labeled/p</span><span class="hspace">&nbsp;</span><span class="RktVal">"the integer: false"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">string:1:13: parse error</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">unexpected: f</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: integer</span></p></td></tr></table></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="choice.html" title="backward to &quot;2 Parsers with Choice&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="choice.html" title="up to &quot;2 Parsers with Choice&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Parsing_sequences.html" title="forward to &quot;2.2 Parsing sequences&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>